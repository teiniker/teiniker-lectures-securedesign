# OS Command Injection

## Execute a Shell Command
The `system()` function is a standard C library function that allows you 
to execute shell commands from within a C program. It provides a simple 
way to invoke command-line commands and shell scripts.

Here is the general syntax of the `system()` function:
```C
int system(const char *command);
```

The `system()` function takes a single argument command, which is a string 
representing the command to be executed in the shell. 
The command string can include any valid shell command, including command-line 
arguments and options.

When the `system()` function is called, it creates a new shell process and passes 
the command string to the shell for execution. 

The `system()` function returns an integer value, which can have the following 
meanings:
* If the command was executed successfully, `system()` returns the termination 
    status of the command.
* If the command could not be executed or the shell could not be started, 
    `system()` returns `-1`.
* If the command was executed but terminated with an error, `system()` returns 
    a value indicating the nature of the error.

The `system()` function is often used for simple command execution and doesn't 
provide direct access to the command's input or output. It relies on the standard 
input, output, and error streams (stdin, stdout, and stderr) of the parent process 
(your C program) and the shell process that it spawns.


To display the `stdout` and `stderr` output generated by the executed shell 
command, you can redirect the output streams using `popen()` instead of `system()`.

```C
  // Open a pipe and execute the command
    FILE *pipe = popen(command, "r");
    if (pipe == NULL) 
    {
        printf("Failed to execute the command.\n");
        return 1;
    }

    // Read and display the output from stdout
    char buffer[BUFFER_SIZE];
    while (fgets(buffer, BUFFER_SIZE, pipe) != NULL) 
    {
        printf("%s", buffer);
    }

    // Close the pipe
    pclose(pipe);
```

The `popen()` function is used to open a pipe and execute the command 
specified as the command-line argument. The `"r"` argument indicates that 
we want to read the output of the command.

Next, we use a `while` loop with `fgets()` to read the output from the 
stdout of the executed command. The output is read line by line into the 
buffer and then displayed using `printf()`.

After reading all the output, the pipe is closed using `pclose()`.

Please note that the above program captures and displays only the stdout output. 
If we also want to capture and display the `stderr` output, you can redirect 
the `stderr` to the `stdout` by appending `2>&1` to the command when invoking 
`popen()`. 

```C
FILE *pipe = popen(command, "r 2>&1");
```

This way, both `stdout` and `stderr` output will be merged and captured 
in the pipe, and we can read and display it in the same manner as shown 
in the program.



## Attack the Execution

A command injection attack, also known as shell injection or OS command injection, 
is a type of security vulnerability that occurs when **an application allows 
user-controlled input to be directly included in a command that is executed by 
the underlying operating system shell**. 

This can happen if the application fails to properly validate or sanitize user input 
before using it to construct a shell command.

Here's an overview of how a command injection attack can work:

* **User input**: The attacker identifies a vulnerable input field in the 
    application, such as a text box or URL parameter, where they can provide 
    input that will be used in a shell command.

* **Injection**: The attacker crafts their input in a way that includes malicious 
    shell commands or characters that can alter the structure of the original command.

* **Command execution**: The application, without proper input validation, directly 
    incorporates the user-controlled input into a shell command and executes it.

* **Exploitation**: The injected command is executed by the underlying shell, leading 
    to unintended consequences. The attacker can execute arbitrary commands, modify 
    files, access sensitive information, or perform other malicious actions, depending 
    on the capabilities of the injected command.

Command injection attacks can have severe consequences, including unauthorized 
access to systems, data leakage, system compromise, and potential damage to the 
application and infrastructure.

```C
    // Vulnerability: Missing input validation for argv[1] !!!
    char command[COMMAND_SIZE];
    snprintf(command, COMMAND_SIZE, "ls -l %s", argv[1]);

    // Open a pipe and execute the command
    FILE *pipe = popen(command, "r");
```

_Example_: List a file with a given filename
```
$ ./command-injection Makefile
-rw-r--r-- 1 student student 496 Jun 29 13:02 Makefile
```

_Example_: Add an attack string `"; cat /etc/passwd"` to the filename
```
$ ./command-injection "Makefile; cat /etc/passwd"
-rw-r--r-- 1 student student 496 Jun 29 13:02 Makefile
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...
```

**Prevention measures for command injection attacks** include:

* **Input validation**: Validate all user input to ensure that it 
    doesn't contain any unexpected or malicious characters. Reject 
    characters that have a special meaning in shell commands.

* **Least privilege**: Ensure that the application and the underlying 
    system have the least privilege necessary to perform their intended 
    functions. Restrict access to sensitive resources and ensure that 
    the application runs with limited permissions.


## References
* [OWASP: Command Injection](https://owasp.org/www-community/attacks/Command_Injection)
* [CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')](https://cwe.mitre.org/data/definitions/78.html)


*Egon Teiniker, 2017 - 2023, GPL v3.0*
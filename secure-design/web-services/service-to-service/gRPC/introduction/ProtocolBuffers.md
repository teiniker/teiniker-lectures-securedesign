# Protocol Buffers

The main difference between gRPC here is the way that it encodes the message.
For encoding messages, gRPC uses protocol buffers.

Protocol buffers are a **language-agnostic**, **platform-neutral**, **extensible mechanism** for 
**serializing structured data**.

## Message Encoding Using Protocol Buffers

Defining the service using protocol buffers includes defining remote methods in the service 
and defining messages we want to send across the network.

The definitions in a `.proto` file are simple: you add a message for each data structure you 
want to serialize, then specify a name and a type for each field in the message. 

_Example_: `.proto` file  
```
    package org.se.lab;

    syntax = "proto3";
    option java_multiple_files = true;

    enum Role
    {
      GUEST = 0;
      USER = 1;
      ADMIN = 2;
    }

    message Person
    {
        int32 id = 1;
        string name = 2;
        string password = 3;
        Role role = 4;
    }
    
    message AddressBook
    {
        repeated Person people = 1;
    }
```

The `.proto` file starts with a **package declaration**, which helps to prevent naming conflicts between different projects.

After the package declaration, you can use three **options that are Java-specific**: 
* **java_multiple_files**: The `java_multiple_files = true` option enables generating a separate `.java` file for each 
    generated class (instead of the legacy behavior of generating a single `.java` file for the wrapper class, 
    using the wrapper class as an outer class, and nesting all the other classes inside the wrapper class).

* **java_package**: java_package specifies in what Java package name your generated classes should live.
     If you don't specify this explicitly, it simply matches the package name given by the package 
     declaration, but these names usually aren't appropriate Java package names (since they usually 
     don't start with a domain name).

* **java_outer_classname**: The java_outer_classname option defines the class name of the wrapper class which will represent this file.
    If you don't give a `java_outer_classname` explicitly, it will be generated by converting the file name to upper camel case.
    For example, `my_proto.proto` would, by default, use `MyProto` as the wrapper class name.

We can specify an **enumeration type** which is a  pre-defined list of values.

Next, we have our **message definitions**. A message is just an aggregate containing a set of **typed fields**. 
Many standard simple data types are available as field types, including `bool`, `int32`, `float`, `double`, and `string`. 
You can also add further structure to your messages by using other message types as field types.
You can even define message types nested inside other messages .

The `= 1`, `= 2` markers on each element identify the **unique tag** that field uses in the binary encoding. 
Tag numbers 1-15 require one less byte to encode than higher numbers, so as an optimization you can decide to 
use those tags for the commonly used or repeated elements, leaving tags 16 and higher for less-commonly used 
optional elements. 

Each field must be annotated with one of the following **modifiers**:

* **repeated**: the field may be repeated any number of times (including zero). 
    The order of the repeated values will be preserved in the protocol buffer. 
    Think of repeated fields as dynamically sized arrays.

_Example_: [gRPC-ProtocolBuffers](../gRPC-ProtocolBuffers)

 
## Compiling Protocol Buffers	

We can use either a command line tool or a Maven plugin to generate Java code from the proto file.

### Protocol Buffer Compiler
To install the command line compiler for `.protp` files, type:
```
$ sudo apt install -y protobuf-compiler
$ protoc --version
libprotoc 3.12.4
```

Now we can run the compiler, specifying the **source directory** (where your application's source code lives – 
the current directory is used if you don't provide a value), the **destination directory** (where you want the 
generated code to go; often the same as $SRC_DIR), and the **path to our .proto file**. 
```
$ protoc -I=$SRC_DIR --java_out=$DST_DIR $SRC_DIR/filename.proto
```

_Example_: [gRPC-ProtocolBuffers-protoc](../gRPC-ProtocolBuffers-protoc)


### Maven Plugin 

We can also use the `protobuf-maven-plugin` Maven plugin which executes the Protocol Buffer compiler before the
`compile` step of the build process.

Note that be using this plugin, we don't need to install the `protoc` compiler for the command line.

```
    <plugin>
        <groupId>org.xolstice.maven.plugins</groupId>
        <artifactId>protobuf-maven-plugin</artifactId>
        <version>0.6.1</version>
        <configuration>
            <protocArtifact>com.google.protobuf:protoc:3.5.1-1:exe:${os.detected.classifier}</protocArtifact>
            <pluginId>grpc-java</pluginId>
            <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.16.1:exe:${os.detected.classifier}</pluginArtifact>
        </configuration>
        <executions>
            <execution>
                <goals>
                    <goal>compile</goal>
                    <goal>compile-custom</goal>
                </goals>
            </execution>
        </executions>
    </plugin>
```

To include the generated code into  the `compile` step, we use the `build-helper-maven-plugin` Maven plugin.
Thus, Java source files generated to `target/generated-sources/protobuf/java/` will also be compiled together
with the manually written code.

```
    <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>build-helper-maven-plugin</artifactId>
        <executions>
            <execution>
                <id>add-source</id>
                <phase>generate-sources</phase>
                <goals>
                    <goal>add-source</goal>
                </goals>
                <configuration>
                    <sources>
                        <source>${project.build.directory}/generated-sources/protobuf/java/</source>
                    </sources>
                </configuration>
            </execution>
        </executions>
    </plugin>
```

## The Protocol Buffer API
For each `message` in the `.proto` file, a **Java class** will be generated.
Each class has its own **Builder class** that you use to create instances of that class. 

_Example_: Generated Java class
```Java
public final class org.se.lab.Person 
        extends com.google.protobuf.GeneratedMessageV3 
        implements org.se.lab.PersonOrBuilder
{
    public int getId();
    public java.lang.String getName();
    public java.lang.String getPassword();
    public org.se.lab.Role getRole();
  
    public boolean equals(java.lang.Object);
    public int hashCode();

    public static org.se.lab.Person$Builder newBuilder();
    // ...
}

```

The **message classes** generated by the protocol buffer compiler are all **immutable**.
Once a message object is constructed, it cannot be modified, just like a Java String.

Both messages and builders have auto-generated **accessor methods** for each field of the message: 
messages have only getters while builders have both getters and setters. 
There are simple JavaBeans-style **getters and setters** for each field. 
There are also has getters for each singular field which return true if that field has been set. 
Finally, each field has a `clear()` method that un-sets the field back to its empty state.

**Repeated fields** have some extra methods – a `count()` method (which is just shorthand for the list's size), 
getters and setters which get or set a specific element of the list by `index`, an `add()` method which appends 
a new element to the list, and an `addAll()` method which adds an entire container full of elements to the list.

Notice how these **accessor methods use camel-case naming**, even though the `.proto` file uses 
lowercase-with-underscores. This transformation is done automatically by the protocol buffer compiler 
so that the generated classes match standard Java style conventions.
You should always use **lowercase-with-underscores** for field names in your `.proto` files; 
this ensures good naming practice in all the generated languages. 


## Builders vs. Messages

To construct a message, you must first construct a **builder**, set any fields you want to set to your 
chosen values, then call the builder's `build()` method.

_Example_: Using a builder to construct a message object
```Java
    Person person = Person.newBuilder()
            .setId(7)
            .setName("homer")
            .setPassword("$2y$12$9gRSvDCPp9lC/JBBo7jCZe.mXhpOiWk4z.y04YJ2NXzUo7qsKbg.S")
            .setRole(Role.ADMIN)
            .build();
```

## Standard Message Methods
Each message and builder class also contains a number of other methods that let you check or 
manipulate the entire message, including:
* **isInitialized()**: checks if all the required fields have been set.
* **toString()**: returns a human-readable representation of the message, particularly useful for debugging.
* **mergeFrom(Message other)**: (builder only) merges the contents of other into this message, 
    overwriting singular scalar fields, merging composite fields, and concatenating repeated fields.
* **clear()**: (builder only) clears all the fields back to the empty state.

These methods implement the `Message` and `Message.Builder` interfaces shared by all Java messages and builders.


## Parsing and Serialization
Each protocol buffer class has methods for writing and reading messages of your chosen type 
using the protocol buffer binary format. These include:
* **byte[] toByteArray()**: serializes the message and returns a byte array containing its raw bytes.
* **static Person parseFrom(byte[] data)**: parses a message from the given byte array.
* **void writeTo(OutputStream output)**: serializes the message and writes it to an OutputStream.
* **static Person parseFrom(InputStream input)**: reads and parses a message from an InputStream.

_Example_: Serialize and deserialize a message object
```Java
	@Test
    public void testPersonSerialization() throws InvalidProtocolBufferException
        {
        byte[] bytes = person.toByteArray();

        System.out.println(Hex.encodeHexString(bytes));

        Person clone = Person.parseFrom(bytes);
        System.out.println(clone.toString());
        }
```

This test case produces the following output:
```
08071205686f6d65721a3c24327924313224396752537644435070396c432f4a42426f376a435a652e6d5868704f69576b347a2e793034594a324e587a556f3771734b62672e532002
id: 7
name: "homer"
password: "$2y$12$9gRSvDCPp9lC/JBBo7jCZe.mXhpOiWk4z.y04YJ2NXzUo7qsKbg.S"
role: ADMIN
```
First, the message object is serialized into a hex string.
Then, from the byte array a new instance of the message object will be created and its `toString()` method will be executed.

Protocol Buffers and Object Oriented Design Protocol buffer classes are basically **data holders**
(like structs in C) that **don't provide additional functionality**; they don't make good first 
class citizens in an object model. 

If you want to add richer behavior to a generated class, the best way to do this is to wrap the 
generated protocol buffer class in an application-specific class. 


## Extending a Protocol Buffer

If we want your new buffers to be **backwards-compatible**, and your old buffers to be **forward-compatible** 
then there are some rules you need to follow. In the new version of the protocol buffer:
* We must not change the tag numbers of any existing fields.
* We must not add or delete any required fields.
* We may delete optional or repeated fields.	
* We may add new optional or repeated fields but you must use fresh tag numbers 
    (that is, tag numbers that were never used in this protocol buffer, not even by deleted fields).

If we follow these rules, old code will read new messages and simply ignore any new fields. 
To the old code, optional fields that were deleted will simply have their default value, and deleted 
repeated fields will be empty. New code will also transparently read old messages. 


## References
* [Protocol Buffers](https://developers.google.com/protocol-buffers)
* [Protocol Buffer Compiler Installation](https://grpc.io/docs/protoc-installation/)
* [Java Generated Code](https://developers.google.com/protocol-buffers/docs/reference/java-generated)

* Kasun Indrasiri, Danesh Kuruppu. **gRPC: Up and Running**. O'Reilly . 
  * Chapter 4: gRPC: Under the Hood

*Egon Teiniker, 2016-2022, GPL v3.0*
